{"version":3,"file":"index.umd.min.js","sources":["../node_modules/insert-css/index.js","../node_modules/penpal/lib/enums.js","../node_modules/penpal/lib/parent/getOriginFromSrc.js","../node_modules/penpal/lib/errorSerialization.js","../node_modules/penpal/lib/generateId.js","../node_modules/penpal/lib/methodSerialization.js","../node_modules/penpal/lib/connectCallSender.js","../node_modules/penpal/lib/parent/handleAckMessageFactory.js","../node_modules/penpal/lib/connectCallReceiver.js","../node_modules/penpal/lib/parent/monitorIframeRemoval.js","../node_modules/penpal/lib/parent/connectToChild.js","../node_modules/penpal/lib/createLogger.js","../node_modules/penpal/lib/createDestructor.js","../node_modules/penpal/lib/parent/validateIframeHasSrcOrSrcDoc.js","../node_modules/penpal/lib/parent/handleSynMessageFactory.js","../node_modules/penpal/lib/startConnectionTimeout.js","../node_modules/when-dom-ready/dist/index.es2015.js","../src/lib/useCsvPlugin.ts"],"sourcesContent":["var containers = []; // will store container HTMLElement references\nvar styleElements = []; // will store {prepend: HTMLElement, append: HTMLElement}\n\nvar usage = 'insert-css: You need to provide a CSS string. Usage: insertCss(cssString[, options]).';\n\nfunction insertCss(css, options) {\n    options = options || {};\n\n    if (css === undefined) {\n        throw new Error(usage);\n    }\n\n    var position = options.prepend === true ? 'prepend' : 'append';\n    var container = options.container !== undefined ? options.container : document.querySelector('head');\n    var containerId = containers.indexOf(container);\n\n    // first time we see this container, create the necessary entries\n    if (containerId === -1) {\n        containerId = containers.push(container) - 1;\n        styleElements[containerId] = {};\n    }\n\n    // try to get the correponding container + position styleElement, create it otherwise\n    var styleElement;\n\n    if (styleElements[containerId] !== undefined && styleElements[containerId][position] !== undefined) {\n        styleElement = styleElements[containerId][position];\n    } else {\n        styleElement = styleElements[containerId][position] = createStyleElement();\n\n        if (position === 'prepend') {\n            container.insertBefore(styleElement, container.childNodes[0]);\n        } else {\n            container.appendChild(styleElement);\n        }\n    }\n\n    // strip potential UTF-8 BOM if css was read from a file\n    if (css.charCodeAt(0) === 0xFEFF) { css = css.substr(1, css.length); }\n\n    // actually add the stylesheet\n    if (styleElement.styleSheet) {\n        styleElement.styleSheet.cssText += css\n    } else {\n        styleElement.textContent += css;\n    }\n\n    return styleElement;\n};\n\nfunction createStyleElement() {\n    var styleElement = document.createElement('style');\n    styleElement.setAttribute('type', 'text/css');\n    return styleElement;\n}\n\nmodule.exports = insertCss;\nmodule.exports.insertCss = insertCss;\n","export var MessageType;\n(function (MessageType) {\n    MessageType[\"Call\"] = \"call\";\n    MessageType[\"Reply\"] = \"reply\";\n    MessageType[\"Syn\"] = \"syn\";\n    MessageType[\"SynAck\"] = \"synAck\";\n    MessageType[\"Ack\"] = \"ack\";\n})(MessageType || (MessageType = {}));\nexport var Resolution;\n(function (Resolution) {\n    Resolution[\"Fulfilled\"] = \"fulfilled\";\n    Resolution[\"Rejected\"] = \"rejected\";\n})(Resolution || (Resolution = {}));\nexport var ErrorCode;\n(function (ErrorCode) {\n    ErrorCode[\"ConnectionDestroyed\"] = \"ConnectionDestroyed\";\n    ErrorCode[\"ConnectionTimeout\"] = \"ConnectionTimeout\";\n    ErrorCode[\"NoIframeSrc\"] = \"NoIframeSrc\";\n})(ErrorCode || (ErrorCode = {}));\nexport var NativeErrorName;\n(function (NativeErrorName) {\n    NativeErrorName[\"DataCloneError\"] = \"DataCloneError\";\n})(NativeErrorName || (NativeErrorName = {}));\nexport var NativeEventType;\n(function (NativeEventType) {\n    NativeEventType[\"Message\"] = \"message\";\n})(NativeEventType || (NativeEventType = {}));\n","const DEFAULT_PORT_BY_PROTOCOL = {\n    'http:': '80',\n    'https:': '443',\n};\nconst URL_REGEX = /^(https?:)?\\/\\/([^/:]+)?(:(\\d+))?/;\nconst opaqueOriginSchemes = ['file:', 'data:'];\n/**\n * Converts a src value into an origin.\n */\nexport default (src) => {\n    if (src && opaqueOriginSchemes.find((scheme) => src.startsWith(scheme))) {\n        // The origin of the child document is an opaque origin and its\n        // serialization is \"null\"\n        // https://html.spec.whatwg.org/multipage/origin.html#origin\n        return 'null';\n    }\n    // Note that if src is undefined, then srcdoc is being used instead of src\n    // and we can follow this same logic below to get the origin of the parent,\n    // which is the origin that we will need to use.\n    const location = document.location;\n    const regexResult = URL_REGEX.exec(src);\n    let protocol;\n    let hostname;\n    let port;\n    if (regexResult) {\n        // It's an absolute URL. Use the parsed info.\n        // regexResult[1] will be undefined if the URL starts with //\n        protocol = regexResult[1] ? regexResult[1] : location.protocol;\n        hostname = regexResult[2];\n        port = regexResult[4];\n    }\n    else {\n        // It's a relative path. Use the current location's info.\n        protocol = location.protocol;\n        hostname = location.hostname;\n        port = location.port;\n    }\n    // If the port is the default for the protocol, we don't want to add it to the origin string\n    // or it won't match the message's event.origin.\n    const portSuffix = port && port !== DEFAULT_PORT_BY_PROTOCOL[protocol] ? `:${port}` : '';\n    return `${protocol}//${hostname}${portSuffix}`;\n};\n","/**\n * Converts an error object into a plain object.\n */\nexport const serializeError = ({ name, message, stack, }) => ({\n    name,\n    message,\n    stack,\n});\n/**\n * Converts a plain object into an error object.\n */\nexport const deserializeError = (obj) => {\n    const deserializedError = new Error();\n    // @ts-ignore\n    Object.keys(obj).forEach((key) => (deserializedError[key] = obj[key]));\n    return deserializedError;\n};\n","let id = 0;\n/**\n * @return {number} A unique ID (not universally unique)\n */\nexport default () => ++id;\n","const KEY_PATH_DELIMITER = '.';\nconst keyPathToSegments = (keyPath) => keyPath ? keyPath.split(KEY_PATH_DELIMITER) : [];\nconst segmentsToKeyPath = (segments) => segments.join(KEY_PATH_DELIMITER);\nconst createKeyPath = (key, prefix) => {\n    const segments = keyPathToSegments(prefix || '');\n    segments.push(key);\n    return segmentsToKeyPath(segments);\n};\n/**\n * Given a `keyPath`, set it to be `value` on `subject`, creating any intermediate\n * objects along the way.\n *\n * @param {Object} subject The object on which to set value.\n * @param {string} keyPath The key path at which to set value.\n * @param {Object} value The value to store at the given key path.\n * @returns {Object} Updated subject.\n */\nexport const setAtKeyPath = (subject, keyPath, value) => {\n    const segments = keyPathToSegments(keyPath);\n    segments.reduce((prevSubject, key, idx) => {\n        if (typeof prevSubject[key] === 'undefined') {\n            prevSubject[key] = {};\n        }\n        if (idx === segments.length - 1) {\n            prevSubject[key] = value;\n        }\n        return prevSubject[key];\n    }, subject);\n    return subject;\n};\n/**\n * Given a dictionary of (nested) keys to function, flatten them to a map\n * from key path to function.\n *\n * @param {Object} methods The (potentially nested) object to serialize.\n * @param {string} prefix A string with which to prefix entries. Typically not intended to be used by consumers.\n * @returns {Object} An map from key path in `methods` to functions.\n */\nexport const serializeMethods = (methods, prefix) => {\n    const flattenedMethods = {};\n    Object.keys(methods).forEach((key) => {\n        const value = methods[key];\n        const keyPath = createKeyPath(key, prefix);\n        if (typeof value === 'object') {\n            // Recurse into any nested children.\n            Object.assign(flattenedMethods, serializeMethods(value, keyPath));\n        }\n        if (typeof value === 'function') {\n            // If we've found a method, expose it.\n            flattenedMethods[keyPath] = value;\n        }\n    });\n    return flattenedMethods;\n};\n/**\n * Given a map of key paths to functions, unpack the key paths to an object.\n *\n * @param {Object} flattenedMethods A map of key paths to functions to unpack.\n * @returns {Object} A (potentially nested) map of functions.\n */\nexport const deserializeMethods = (flattenedMethods) => {\n    const methods = {};\n    for (const keyPath in flattenedMethods) {\n        setAtKeyPath(methods, keyPath, flattenedMethods[keyPath]);\n    }\n    return methods;\n};\n","import generateId from './generateId';\nimport { deserializeError } from './errorSerialization';\nimport { deserializeMethods } from './methodSerialization';\nimport { ErrorCode, MessageType, NativeEventType, Resolution } from './enums';\n/**\n * Augments an object with methods that match those defined by the remote. When these methods are\n * called, a \"call\" message will be sent to the remote, the remote's corresponding method will be\n * executed, and the method's return value will be returned via a message.\n * @param {Object} callSender Sender object that should be augmented with methods.\n * @param {Object} info Information about the local and remote windows.\n * @param {Array} methodKeyPaths Key paths of methods available to be called on the remote.\n * @param {Promise} destructionPromise A promise resolved when destroy() is called on the penpal\n * connection.\n * @returns {Object} The call sender object with methods that may be called.\n */\nexport default (callSender, info, methodKeyPaths, destroyConnection, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    log(`${localName}: Connecting call sender`);\n    const createMethodProxy = (methodName) => {\n        return (...args) => {\n            log(`${localName}: Sending ${methodName}() call`);\n            // This handles the case where the iframe has been removed from the DOM\n            // (and therefore its window closed), the consumer has not yet\n            // called destroy(), and the user calls a method exposed by\n            // the remote. We detect the iframe has been removed and force\n            // a destroy() immediately so that the consumer sees the error saying\n            // the connection has been destroyed. We wrap this check in a try catch\n            // because Edge throws an \"Object expected\" error when accessing\n            // contentWindow.closed on a contentWindow from an iframe that's been\n            // removed from the DOM.\n            let iframeRemoved;\n            try {\n                if (remote.closed) {\n                    iframeRemoved = true;\n                }\n            }\n            catch (e) {\n                iframeRemoved = true;\n            }\n            if (iframeRemoved) {\n                destroyConnection();\n            }\n            if (destroyed) {\n                const error = new Error(`Unable to send ${methodName}() call due ` + `to destroyed connection`);\n                error.code = ErrorCode.ConnectionDestroyed;\n                throw error;\n            }\n            return new Promise((resolve, reject) => {\n                const id = generateId();\n                const handleMessageEvent = (event) => {\n                    if (event.source !== remote ||\n                        event.data.penpal !== MessageType.Reply ||\n                        event.data.id !== id) {\n                        return;\n                    }\n                    if (originForReceiving !== '*' &&\n                        event.origin !== originForReceiving) {\n                        log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n                        return;\n                    }\n                    const replyMessage = event.data;\n                    log(`${localName}: Received ${methodName}() reply`);\n                    local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n                    let returnValue = replyMessage.returnValue;\n                    if (replyMessage.returnValueIsError) {\n                        returnValue = deserializeError(returnValue);\n                    }\n                    (replyMessage.resolution === Resolution.Fulfilled ? resolve : reject)(returnValue);\n                };\n                local.addEventListener(NativeEventType.Message, handleMessageEvent);\n                const callMessage = {\n                    penpal: MessageType.Call,\n                    id,\n                    methodName,\n                    args,\n                };\n                remote.postMessage(callMessage, originForSending);\n            });\n        };\n    };\n    // Wrap each method in a proxy which sends it to the corresponding receiver.\n    const flattenedMethods = methodKeyPaths.reduce((api, name) => {\n        api[name] = createMethodProxy(name);\n        return api;\n    }, {});\n    // Unpack the structure of the provided methods object onto the CallSender, exposing\n    // the methods in the same shape they were provided.\n    Object.assign(callSender, deserializeMethods(flattenedMethods));\n    return () => {\n        destroyed = true;\n    };\n};\n","import connectCallReceiver from '../connectCallReceiver';\nimport connectCallSender from '../connectCallSender';\n/**\n * Handles an ACK handshake message.\n */\nexport default (serializedMethods, childOrigin, originForSending, destructor, log) => {\n    const { destroy, onDestroy } = destructor;\n    let destroyCallReceiver;\n    let receiverMethodNames;\n    // We resolve the promise with the call sender. If the child reconnects\n    // (for example, after refreshing or navigating to another page that\n    // uses Penpal, we'll update the call sender with methods that match the\n    // latest provided by the child.\n    const callSender = {};\n    return (event) => {\n        if (childOrigin !== '*' && event.origin !== childOrigin) {\n            log(`Parent: Handshake - Received ACK message from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n            return;\n        }\n        log('Parent: Handshake - Received ACK');\n        const info = {\n            localName: 'Parent',\n            local: window,\n            remote: event.source,\n            originForSending: originForSending,\n            originForReceiving: childOrigin,\n        };\n        // If the child reconnected, we need to destroy the prior call receiver\n        // before setting up a new one.\n        if (destroyCallReceiver) {\n            destroyCallReceiver();\n        }\n        destroyCallReceiver = connectCallReceiver(info, serializedMethods, log);\n        onDestroy(destroyCallReceiver);\n        // If the child reconnected, we need to remove the methods from the\n        // previous call receiver off the sender.\n        if (receiverMethodNames) {\n            receiverMethodNames.forEach((receiverMethodName) => {\n                delete callSender[receiverMethodName];\n            });\n        }\n        receiverMethodNames = event.data.methodNames;\n        const destroyCallSender = connectCallSender(callSender, info, receiverMethodNames, destroy, log);\n        onDestroy(destroyCallSender);\n        return callSender;\n    };\n};\n","import { serializeError } from './errorSerialization';\nimport { MessageType, NativeEventType, NativeErrorName, Resolution, } from './enums';\n/**\n * Listens for \"call\" messages coming from the remote, executes the corresponding method, and\n * responds with the return value.\n */\nexport default (info, serializedMethods, log) => {\n    const { localName, local, remote, originForSending, originForReceiving, } = info;\n    let destroyed = false;\n    const handleMessageEvent = (event) => {\n        if (event.source !== remote || event.data.penpal !== MessageType.Call) {\n            return;\n        }\n        if (originForReceiving !== '*' && event.origin !== originForReceiving) {\n            log(`${localName} received message from origin ${event.origin} which did not match expected origin ${originForReceiving}`);\n            return;\n        }\n        const callMessage = event.data;\n        const { methodName, args, id } = callMessage;\n        log(`${localName}: Received ${methodName}() call`);\n        const createPromiseHandler = (resolution) => {\n            return (returnValue) => {\n                log(`${localName}: Sending ${methodName}() reply`);\n                if (destroyed) {\n                    // It's possible to throw an error here, but it would need to be thrown asynchronously\n                    // and would only be catchable using window.onerror. This is because the consumer\n                    // is merely returning a value from their method and not calling any function\n                    // that they could wrap in a try-catch. Even if the consumer were to catch the error,\n                    // the value of doing so is questionable. Instead, we'll just log a message.\n                    log(`${localName}: Unable to send ${methodName}() reply due to destroyed connection`);\n                    return;\n                }\n                const message = {\n                    penpal: MessageType.Reply,\n                    id,\n                    resolution,\n                    returnValue,\n                };\n                if (resolution === Resolution.Rejected &&\n                    returnValue instanceof Error) {\n                    message.returnValue = serializeError(returnValue);\n                    message.returnValueIsError = true;\n                }\n                try {\n                    remote.postMessage(message, originForSending);\n                }\n                catch (err) {\n                    // If a consumer attempts to send an object that's not cloneable (e.g., window),\n                    // we want to ensure the receiver's promise gets rejected.\n                    if (err.name === NativeErrorName.DataCloneError) {\n                        const errorReplyMessage = {\n                            penpal: MessageType.Reply,\n                            id,\n                            resolution: Resolution.Rejected,\n                            returnValue: serializeError(err),\n                            returnValueIsError: true,\n                        };\n                        remote.postMessage(errorReplyMessage, originForSending);\n                    }\n                    throw err;\n                }\n            };\n        };\n        new Promise((resolve) => resolve(serializedMethods[methodName].apply(serializedMethods, args))).then(createPromiseHandler(Resolution.Fulfilled), createPromiseHandler(Resolution.Rejected));\n    };\n    local.addEventListener(NativeEventType.Message, handleMessageEvent);\n    return () => {\n        destroyed = true;\n        local.removeEventListener(NativeEventType.Message, handleMessageEvent);\n    };\n};\n","const CHECK_IFRAME_IN_DOC_INTERVAL = 60000;\n/**\n * Monitors for iframe removal and destroys connection if iframe\n * is found to have been removed from DOM. This is to prevent memory\n * leaks when the iframe is removed from the document and the consumer\n * hasn't called destroy(). Without this, event listeners attached to\n * the window would stick around and since the event handlers have a\n * reference to the iframe in their closures, the iframe would stick\n * around too.\n */\nexport default (iframe, destructor) => {\n    const { destroy, onDestroy } = destructor;\n    const checkIframeInDocIntervalId = setInterval(() => {\n        if (!iframe.isConnected) {\n            clearInterval(checkIframeInDocIntervalId);\n            destroy();\n        }\n    }, CHECK_IFRAME_IN_DOC_INTERVAL);\n    onDestroy(() => {\n        clearInterval(checkIframeInDocIntervalId);\n    });\n};\n","import { MessageType, NativeEventType } from '../enums';\nimport createDestructor from '../createDestructor';\nimport createLogger from '../createLogger';\nimport getOriginFromSrc from './getOriginFromSrc';\nimport handleAckMessageFactory from './handleAckMessageFactory';\nimport handleSynMessageFactory from './handleSynMessageFactory';\nimport { serializeMethods } from '../methodSerialization';\nimport monitorIframeRemoval from './monitorIframeRemoval';\nimport startConnectionTimeout from '../startConnectionTimeout';\nimport validateIframeHasSrcOrSrcDoc from './validateIframeHasSrcOrSrcDoc';\n/**\n * Attempts to establish communication with an iframe.\n */\nexport default (options) => {\n    let { iframe, methods = {}, childOrigin, timeout, debug = false } = options;\n    const log = createLogger(debug);\n    const destructor = createDestructor('Parent', log);\n    const { onDestroy, destroy } = destructor;\n    if (!childOrigin) {\n        validateIframeHasSrcOrSrcDoc(iframe);\n        childOrigin = getOriginFromSrc(iframe.src);\n    }\n    // If event.origin is \"null\", the remote protocol is file: or data: and we\n    // must post messages with \"*\" as targetOrigin when sending messages.\n    // https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage#Using_window.postMessage_in_extensions\n    const originForSending = childOrigin === 'null' ? '*' : childOrigin;\n    const serializedMethods = serializeMethods(methods);\n    const handleSynMessage = handleSynMessageFactory(log, serializedMethods, childOrigin, originForSending);\n    const handleAckMessage = handleAckMessageFactory(serializedMethods, childOrigin, originForSending, destructor, log);\n    const promise = new Promise((resolve, reject) => {\n        const stopConnectionTimeout = startConnectionTimeout(timeout, destroy);\n        const handleMessage = (event) => {\n            if (event.source !== iframe.contentWindow || !event.data) {\n                return;\n            }\n            if (event.data.penpal === MessageType.Syn) {\n                handleSynMessage(event);\n                return;\n            }\n            if (event.data.penpal === MessageType.Ack) {\n                const callSender = handleAckMessage(event);\n                if (callSender) {\n                    stopConnectionTimeout();\n                    resolve(callSender);\n                }\n                return;\n            }\n        };\n        window.addEventListener(NativeEventType.Message, handleMessage);\n        log('Parent: Awaiting handshake');\n        monitorIframeRemoval(iframe, destructor);\n        onDestroy((error) => {\n            window.removeEventListener(NativeEventType.Message, handleMessage);\n            if (error) {\n                reject(error);\n            }\n        });\n    });\n    return {\n        promise,\n        destroy() {\n            // Don't allow consumer to pass an error into destroy.\n            destroy();\n        },\n    };\n};\n","export default (debug) => {\n    /**\n     * Logs a message if debug is enabled.\n     */\n    return (...args) => {\n        if (debug) {\n            console.log('[Penpal]', ...args); // eslint-disable-line no-console\n        }\n    };\n};\n","export default (localName, log) => {\n    const callbacks = [];\n    let destroyed = false;\n    return {\n        destroy(error) {\n            if (!destroyed) {\n                destroyed = true;\n                log(`${localName}: Destroying connection`);\n                callbacks.forEach((callback) => {\n                    callback(error);\n                });\n            }\n        },\n        onDestroy(callback) {\n            destroyed ? callback() : callbacks.push(callback);\n        },\n    };\n};\n","import { ErrorCode } from '../enums';\nexport default (iframe) => {\n    if (!iframe.src && !iframe.srcdoc) {\n        const error = new Error('Iframe must have src or srcdoc property defined.');\n        error.code = ErrorCode.NoIframeSrc;\n        throw error;\n    }\n};\n","import { MessageType } from '../enums';\n/**\n * Handles a SYN handshake message.\n */\nexport default (log, serializedMethods, childOrigin, originForSending) => {\n    return (event) => {\n        // Under specific timing circumstances, we can receive an event\n        // whose source is null. This seems to happen when the child iframe is\n        // removed from the DOM about the same time it has sent the SYN event.\n        // https://github.com/Aaronius/penpal/issues/85\n        if (!event.source) {\n            return;\n        }\n        if (childOrigin !== '*' && event.origin !== childOrigin) {\n            log(`Parent: Handshake - Received SYN message from origin ${event.origin} which did not match expected origin ${childOrigin}`);\n            return;\n        }\n        log('Parent: Handshake - Received SYN, responding with SYN-ACK');\n        const synAckMessage = {\n            penpal: MessageType.SynAck,\n            methodNames: Object.keys(serializedMethods),\n        };\n        event.source.postMessage(synAckMessage, originForSending);\n    };\n};\n","import { ErrorCode } from './enums';\n/**\n * Starts a timeout and calls the callback with an error\n * if the timeout completes before the stop function is called.\n */\nexport default (timeout, callback) => {\n    let timeoutId;\n    if (timeout !== undefined) {\n        timeoutId = window.setTimeout(() => {\n            const error = new Error(`Connection timed out after ${timeout}ms`);\n            error.code = ErrorCode.ConnectionTimeout;\n            callback(error);\n        }, timeout);\n    }\n    return () => {\n        clearTimeout(timeoutId);\n    };\n};\n","/* eslint no-void: \"off\" */\n\n// Loaded ready states\nvar loadedStates = ['interactive', 'complete'];\n\n// Return Promise\nvar whenDomReady = function whenDomReady(cb, doc) {\n\treturn new Promise(function (resolve) {\n\t\t// Allow doc to be passed in as the lone first param\n\t\tif (cb && typeof cb !== 'function') {\n\t\t\tdoc = cb;\n\t\t\tcb = null;\n\t\t}\n\n\t\t// Use global document if we don't have one\n\t\tdoc = doc || window.document;\n\n\t\t// Handle DOM load\n\t\tvar done = function done() {\n\t\t\treturn resolve(void (cb && setTimeout(cb)));\n\t\t};\n\n\t\t// Resolve now if DOM has already loaded\n\t\t// Otherwise wait for DOMContentLoaded\n\t\tif (loadedStates.indexOf(doc.readyState) !== -1) {\n\t\t\tdone();\n\t\t} else {\n\t\t\tdoc.addEventListener('DOMContentLoaded', done);\n\t\t}\n\t});\n};\n\n// Promise chain helper\nwhenDomReady.resume = function (doc) {\n\treturn function (val) {\n\t\treturn whenDomReady(doc).then(function () {\n\t\t\treturn val;\n\t\t});\n\t};\n};\n\nexport default whenDomReady;\n//# sourceMappingURL=index.es2015.js.map\n","import { insertCss } from \"insert-css\";\nimport { connectToChild } from \"penpal\";\nimport whenDomReady from \"when-dom-ready\";\n\nimport type {\n  CsvData,\n  DynamicColumnsType,\n  onDataResponseWithBatching,\n  onDataResponseWithoutBatching,\n  onRecordEditType,\n  onRecordsInitialType,\n  ThemeType,\n} from \"./types\";\n\n// eslint-disable-next-line dot-notation\nconst MOUNT_URL = process.env[\"MOUNT_URL\"] || \"http://localhost:3000/importer\";\n\nconst insertIframe = (id: string, importerDisplay: \"inline\" | \"modal\") => {\n  const usecsvInlineWrapper = document.getElementById(\"usecsv-importer-inline-wrapper\");\n\n  const usecsvContainerStyles =\n    importerDisplay === \"modal\" || !usecsvInlineWrapper\n      ? `.usecsv_container { position: fixed; top: 0px; bottom: 0; right: 0; left: 0; z-index: 100000; }`\n      : ``;\n\n  insertCss(`\n  ${usecsvContainerStyles}\n  .usecsv_container iframe {\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    border-width: 0;\n  }\n  .usecsv_container {\n    overflow: hidden;\n    overscroll-behavior-x: none;\n  }\n`);\n\n  document.body.insertAdjacentHTML(\"beforeend\", `<div id=${id} class=\"usecsv_container loading\"></div>`);\n  const iframe = document.createElement(\"iframe\");\n  iframe.setAttribute(\"src\", MOUNT_URL);\n  const usecsvContainer = document.getElementById(id);\n  usecsvContainer?.appendChild(iframe);\n  if (importerDisplay === \"inline\" && usecsvInlineWrapper) {\n    // usecsvInlineWrapper > usecsvContainer > iframe\n    usecsvInlineWrapper?.appendChild(usecsvContainer as HTMLElement);\n  }\n\n  return iframe;\n};\n\nconst useCsvPlugin = ({\n  importerKey,\n  user,\n  metadata,\n  onData,\n  onRecordsInitial,\n  onRecordEdit,\n  importerDisplay = \"modal\",\n  onClose,\n  theme,\n  batchSize,\n  sampleFileURL,\n  downloadExampleButton = true,\n  dynamicColumns,\n}: {\n  importerKey: string;\n  user?: Record<string, string | number>;\n  metadata?: Record<string, string | number>;\n  onData?: (data: CsvData, close: () => void) => void | onDataResponseWithoutBatching | onDataResponseWithBatching;\n  onRecordsInitial?: onRecordsInitialType;\n  onRecordEdit?: onRecordEditType;\n  importerDisplay?: \"modal\" | \"inline\";\n  onClose?: () => void;\n  theme?: ThemeType;\n  batchSize?: number;\n  sampleFileURL?: string;\n  downloadExampleButton?: boolean;\n  dynamicColumns?: DynamicColumnsType;\n}) => {\n  const id = `usecsv-${Math.round(Math.random() * 100000000)}`;\n  return whenDomReady().then(() => {\n    const iframe = insertIframe(id, importerDisplay);\n    const closeIframe = () => {\n      document.getElementById(id)?.remove();\n    };\n    const iframeConnection = connectToChild({\n      iframe,\n      methods: {\n        closeIframe,\n        ...(onData\n          ? {\n              onData: (data: CsvData) => onData(data, closeIframe),\n            }\n          : {}),\n        ...(onRecordsInitial\n          ? {\n              onRecordsInitial,\n            }\n          : {}),\n        ...(onRecordEdit\n          ? {\n              onRecordEdit,\n            }\n          : {}),\n        ...(onClose\n          ? {\n              onClose,\n            }\n          : {}),\n      },\n    });\n    iframeConnection.promise.then((child: any) => {\n      document.getElementById(id)?.classList.remove(\"loading\");\n      // eslint-disable-next-line dot-notation\n      child[\"setParams\"] &&\n        // eslint-disable-next-line dot-notation\n        child[\"setParams\"]({\n          importerKey,\n          user,\n          metadata,\n          importerDisplay,\n          theme,\n          batchSize,\n          sampleFileURL,\n          downloadExampleButton,\n          dynamicColumns,\n        });\n    });\n    return iframeConnection;\n  });\n};\n\nexport default useCsvPlugin;\n"],"names":["containers","styleElements","insertCss","css","options","undefined","Error","styleElement","position","prepend","container","document","querySelector","containerId","indexOf","push","createElement","setAttribute","createStyleElement","insertBefore","childNodes","appendChild","charCodeAt","substr","length","styleSheet","cssText","textContent","MessageType","Resolution","ErrorCode","NativeErrorName","NativeEventType","insertCss_2","DEFAULT_PORT_BY_PROTOCOL","URL_REGEX","opaqueOriginSchemes","serializeError","name","message","stack","id","generateId","keyPathToSegments","keyPath","split","setAtKeyPath","subject","value","segments","reduce","prevSubject","key","idx","serializeMethods","methods","prefix","flattenedMethods","Object","keys","forEach","join","segmentsToKeyPath","createKeyPath","assign","connectCallSender","callSender","info","methodKeyPaths","destroyConnection","log","localName","local","remote","originForSending","originForReceiving","destroyed","createMethodProxy","methodName","args","iframeRemoved","closed","e","error","code","ConnectionDestroyed","Promise","resolve","reject","handleMessageEvent","event","source","data","penpal","Reply","origin","replyMessage","removeEventListener","Message","returnValue","returnValueIsError","obj","deserializedError","deserializeError","resolution","Fulfilled","addEventListener","callMessage","Call","postMessage","api","deserializeMethods","handleAckMessageFactory","serializedMethods","childOrigin","destructor","destroy","onDestroy","destroyCallReceiver","receiverMethodNames","window","createPromiseHandler","Rejected","err","DataCloneError","errorReplyMessage","apply","then","connectCallReceiver","receiverMethodName","methodNames","destroyCallSender","connectToChild","iframe","timeout","debug","console","createLogger","callbacks","callback","createDestructor","src","srcdoc","NoIframeSrc","validateIframeHasSrcOrSrcDoc","find","scheme","startsWith","location","regexResult","exec","protocol","hostname","port","getOriginFromSrc","handleSynMessage","synAckMessage","SynAck","handleSynMessageFactory","handleAckMessage","promise","stopConnectionTimeout","timeoutId","setTimeout","ConnectionTimeout","clearTimeout","startConnectionTimeout","handleMessage","contentWindow","Syn","Ack","checkIframeInDocIntervalId","setInterval","isConnected","clearInterval","monitorIframeRemoval","loadedStates","whenDomReady","cb","doc","done","readyState","resume","val","_a","importerKey","user","metadata","onData","onRecordsInitial","onRecordEdit","_b","importerDisplay","onClose","theme","batchSize","sampleFileURL","_c","downloadExampleButton","dynamicColumns","concat","Math","round","random","usecsvInlineWrapper","getElementById","body","insertAdjacentHTML","usecsvContainer","insertIframe","closeIframe","remove","iframeConnection","__assign","child","classList"],"mappings":"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"}